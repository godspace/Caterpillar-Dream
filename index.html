<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ò–Ω–¥–∏–∫–æ–≤—ã–π –¢—Ä–∞–Ω—Å - –ì–ª—É–±–æ–∫–∞—è –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è</title>
    <style>
        body {
            background-color: #020205; /* –ì–ª—É–±–æ–∫–∏–π —Ç–µ–º–Ω—ã–π –∫–æ—Å–º–æ—Å */
            color: #d3d3d3;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end; 
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #visualizer-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #ui-container {
            width: 80%;
            max-width: 400px;
            text-align: center;
            z-index: 10; 
            margin-bottom: 40px;
            background: rgba(10, 10, 15, 0.6); 
            padding: 25px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transition: opacity 2s ease;
        }
        /* –°–∫—Ä—ã–≤–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø—Ä–∏ –≥–ª—É–±–æ–∫–æ–º –ø–æ–≥—Ä—É–∂–µ–Ω–∏–∏, –µ—Å–ª–∏ –∫—É—Ä—Å–æ—Ä –Ω–µ –¥–≤–∏–≥–∞–µ—Ç—Å—è */
        body.immersed #ui-container {
            opacity: 0.1;
        }
        body.immersed #ui-container:hover {
            opacity: 1;
        }
        #text-source { display: none; }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        select, button {
            padding: 14px;
            border-radius: 10px;
            font-size: 1rem;
            width: 100%;
            outline: none;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s;
        }
        select {
            background: rgba(30, 30, 35, 0.9);
            color: #fff;
        }
        button {
            background: linear-gradient(135deg, #1a1a24 0%, #2a2a3a 100%);
            color: #fff;
            cursor: pointer;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: bold;
        }
        button:hover {
            background: linear-gradient(135deg, #2a2a3a 0%, #3a3a5a 100%);
            box-shadow: 0 0 20px rgba(100, 150, 255, 0.3);
            border-color: rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>

    <canvas id="visualizer-canvas"></canvas>

    <div id="ui-container">
        <div class="controls">
            <select id="voiceSelect"><option value="">–ó–∞–≥—Ä—É–∑–∫–∞ –≥–æ–ª–æ—Å–æ–≤...</option></select>
            <button id="playBtn">–ù–∞—á–∞—Ç—å –ø–æ–≥—Ä—É–∂–µ–Ω–∏–µ</button>
        </div>
    </div>

    <div id="text-source">
        –¢–µ–ø–µ—Ä—å —Ç—ã ‚Äî —ç—Ç–æ —Ç–æ–ª—å–∫–æ —Ä–∏—Ç–º. –¢–≤–æ–µ —Ç–µ–ª–æ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ —Ç—è–∂–µ–ª—ã–π, —Ç–µ–ø–ª—ã–π –ø–µ—Å–æ–∫, –∫–æ—Ç–æ—Ä—ã–π –º–µ–¥–ª–µ–Ω–Ω–æ –ø–µ—Ä–µ—Å—ã–ø–∞–µ—Ç—Å—è –≤ –ø–µ—Å–æ—á–Ω—ã—Ö —á–∞—Å–∞—Ö –≤–µ—á–Ω–æ—Å—Ç–∏. –ö–∞–∂–¥–æ–µ —Å–ª–æ–≤–æ ‚Äî —ç—Ç–æ –≥–ª—É–±–æ–∫–∏–π, –±–∞—Ä—Ö–∞—Ç–Ω—ã–π —É–¥–∞—Ä –∫–æ–ª–æ–∫–æ–ª–∞ –≥–¥–µ-—Ç–æ –ø–æ–¥ –≤–æ–¥–æ–π. –¢—ã —á—É–≤—Å—Ç–≤—É–µ—à—å, –∫–∞–∫ –∑–∞—Ç—ã–ª–æ–∫ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –Ω–µ–≤–µ—Å–æ–º—ã–º, –∞ —á–µ–ª—é—Å—Ç—å —Ä–∞—Å—Å–ª–∞–±–ª—è–µ—Ç—Å—è —Å–∞–º–∞ —Å–æ–±–æ–π. –í–æ–∑–¥—É—Ö –≤–æ–∫—Ä—É–≥ —Ç–µ–±—è —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ø–ª–æ—Ç–Ω—ã–º –∏ –ª–∞—Å–∫–æ–≤—ã–º. –°—Ç–µ–Ω—ã –ø—É–ª—å—Å–∏—Ä—É—é—Ç –≤ —Ç–∞–∫—Ç —Ç–≤–æ–µ–º—É –ø—É–ª—å—Å—É. –û–¥–∏–Ω. –î–≤–∞. –ì–ª—É–±–æ–∫–∏–π, —Ç–µ–ø–ª—ã–π –ø–æ–∫–æ–π.
    </div>

    <script>
        // --- –ì–æ–ª–æ—Å–æ–≤–æ–π –¥–≤–∏–∂–æ–∫ ---
        const synth = window.speechSynthesis;
        const voiceSelect = document.getElementById('voiceSelect');
        const playBtn = document.getElementById('playBtn');
        const textContent = document.getElementById('text-source').innerText;
        
        let voices = [];
        let keepAliveTimer; 

        function populateVoiceList() {
            voices = synth.getVoices().filter(v => v.lang.startsWith('ru'));
            voiceSelect.innerHTML = '';
            voices.forEach((voice) => {
                const option = document.createElement('option');
                option.textContent = voice.name.includes('Natural') || voice.name.includes('Online') ? 'üåü ' + voice.name : voice.name;
                option.setAttribute('data-name', voice.name);
                if(option.textContent.includes('üåü')) option.selected = true;
                voiceSelect.appendChild(option);
            });
        }
        populateVoiceList();
        if (speechSynthesis.onvoiceschanged !== undefined) speechSynthesis.onvoiceschanged = populateVoiceList;

        // --- –ê—É–¥–∏–æ & –í–∏–∑—É–∞–ª–∏–∑–∞—Ç–æ—Ä ---
        let audioCtx, masterGain, delayNode, feedbackNode, analyser, dataArray, bufferLength;
        let canvas, canvasCtx, WIDTH, HEIGHT;
        let drawVisualizerRequest;
        let isPlaying = false;
        let melodyTimeout;
        let sfxTimers = { sand: null, bell: null, heart: null };
        let sfxFlags = { sand: false, bell: false, heart: false };

        let currentHeartVol = 0.3; 
        const maxHeartVol = 0.8;
        const scale = [130.81, 155.56, 174.61, 196.00, 233.08, 261.63, 311.13];

        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();

            masterGain = audioCtx.createGain();
            masterGain.gain.setValueAtTime(1, audioCtx.currentTime); 
            
            const compressor = audioCtx.createDynamicsCompressor();
            compressor.threshold.setValueAtTime(-24, audioCtx.currentTime);
            compressor.knee.setValueAtTime(30, audioCtx.currentTime);
            compressor.ratio.setValueAtTime(12, audioCtx.currentTime);
            compressor.attack.setValueAtTime(0.003, audioCtx.currentTime);
            compressor.release.setValueAtTime(0.25, audioCtx.currentTime);

            masterGain.connect(compressor);

            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 512; 
            analyser.smoothingTimeConstant = 0.85; // –ü–ª–∞–≤–Ω–æ—Å—Ç—å –∑–∞—Ç—É—Ö–∞–Ω–∏—è —á–∞—Å—Ç–æ—Ç (0.8 - 0.95)
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            compressor.connect(analyser);
            analyser.connect(audioCtx.destination);
            
            delayNode = audioCtx.createDelay();
            delayNode.delayTime.value = 0.6; 
            feedbackNode = audioCtx.createGain();
            feedbackNode.gain.value = 0.5; 
            
            delayNode.connect(feedbackNode);
            feedbackNode.connect(delayNode);
            delayNode.connect(masterGain);

            initCanvas();
        }

        // --- –£–ª—É—á—à–µ–Ω–Ω–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ Canvas (Retina / High-DPI) ---
        function initCanvas() {
            canvas = document.getElementById('visualizer-canvas');
            canvasCtx = canvas.getContext('2d');
            
            function resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                WIDTH = window.innerWidth;
                HEIGHT = window.innerHeight;
                canvas.width = WIDTH * dpr;
                canvas.height = HEIGHT * dpr;
                canvasCtx.scale(dpr, dpr);
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        }

        // --- –í–´–°–û–ö–û–ö–ê–ß–ï–°–¢–í–ï–ù–ù–ê–Ø –ì–ï–ù–ï–†–ê–¢–ò–í–ù–ê–Ø –ì–†–ê–§–ò–ö–ê ---
        let hueOffset = 0; 
        let timeRotation = 0;

        function drawVisualizer() {
            drawVisualizerRequest = requestAnimationFrame(drawVisualizer);
            analyser.getByteFrequencyData(dataArray);

            const centerX = WIDTH / 2;
            const centerY = HEIGHT / 2;
            const maxRadius = Math.min(WIDTH, HEIGHT) / 2;

            // 1. –û—á–∏—Å—Ç–∫–∞ —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º –∑–∞—Ç—É—Ö–∞–Ω–∏—è (Trails)
            canvasCtx.globalCompositeOperation = 'source-over';
            canvasCtx.fillStyle = 'rgba(2, 2, 5, 0.15)'; // –û—á–µ–Ω—å —Ç–µ–º–Ω—ã–π —Å–∏–Ω–µ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π —Ñ–æ–Ω
            canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

            // 2. –†–µ–∂–∏–º –Ω–∞–ª–æ–∂–µ–Ω–∏—è –¥–ª—è "–°–≤–µ—á–µ–Ω–∏—è"
            canvasCtx.globalCompositeOperation = 'lighter';

            // –ë–∞–∑–æ–≤—ã–π –±–∞—Å –¥–ª—è —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–≥–æ –ø—É–ª—å—Å–∞
            const bassEnergy = (dataArray[2] + dataArray[4] + dataArray[6]) / 3 / 255;
            const baseRadius = 40 + bassEnergy * 80; 

            hueOffset += 0.2; // –ú–µ–¥–ª–µ–Ω–Ω–∞—è —Å–º–µ–Ω–∞ –ø–∞–ª–∏—Ç—Ä—ã
            timeRotation += 0.001; // –û—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –≤—Å–µ–≥–æ —É–∑–æ—Ä–∞

            const segments = 10; // 10-–ª—É—á–µ–≤–∞—è –º–∞–Ω–¥–∞–ª–∞ (–º–æ–∂–µ—Ç–µ –ø–æ–º–µ–Ω—è—Ç—å –Ω–∞ 6, 8, 12)

            for (let m = 0; m < segments; m++) {
                canvasCtx.save();
                canvasCtx.translate(centerX, centerY);
                
                // –í—Ä–∞—â–∞–µ–º –∫–∞–∂–¥—ã–π —Å–µ–≥–º–µ–Ω—Ç + –æ–±—â–µ–µ –º–µ–¥–ª–µ–Ω–Ω–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ
                const angleOffset = (Math.PI * 2 / segments) * m;
                canvasCtx.rotate(timeRotation + angleOffset);

                // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ç–∏–≤–Ω—ã—Ö –∫—Ä–∏–≤—ã—Ö –¥–ª—è —ç—Ç–æ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞
                canvasCtx.beginPath();
                
                // –¶–≤–µ—Ç–æ–≤–∞—è –≥–∞—Ä–º–æ–Ω–∏—è: –Ω–µ–º–Ω–æ–≥–æ —Å–¥–≤–∏–≥–∞–µ–º —Ü–≤–µ—Ç –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ª—É—á–∞
                const hue = (hueOffset + m * (360 / segments / 2)) % 360; 
                canvasCtx.strokeStyle = `hsla(${hue}, 80%, 60%, 0.6)`;
                canvasCtx.lineWidth = 1.5 + bassEnergy; 
                
                // –ú—è–≥–∫–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ (–æ—Ç–±–∏—Ä–∞–µ—Ç FPS –Ω–∞ —Å–ª–∞–±—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö, –Ω–æ –∑–¥–µ—Å—å –≤—ã–≥–ª—è–¥–∏—Ç –≤–æ–ª—à–µ–±–Ω–æ)
                canvasCtx.shadowBlur = 10;
                canvasCtx.shadowColor = `hsla(${hue}, 100%, 50%, 0.5)`;

                // –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ —á–∞—Å—Ç–æ—Ç–∞–º, —Ä–∏—Å—É—è –ø–ª–∞–≤–Ω—É—é –∫—Ä–∏–≤—É—é
                // –ë–µ—Ä–µ–º –Ω–µ –≤—Å–µ —Ç–æ—á–∫–∏, —á—Ç–æ–±—ã —É–∑–æ—Ä –±—ã–ª –±–æ–ª–µ–µ —á–µ—Ç–∫–∏–º
                let prevX = 0;
                let prevY = baseRadius;

                canvasCtx.moveTo(prevX, prevY);

                const step = 4; // –®–∞–≥ –ø–æ –º–∞—Å—Å–∏–≤—É —á–∞—Å—Ç–æ—Ç (—Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –¥–µ—Ç–∞–ª–µ–π)
                for (let i = step; i < bufferLength - 20; i += step) {
                    const value = dataArray[i];
                    const percent = value / 255;
                    
                    // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –≥—Ä–æ–º–∫–æ—Å—Ç–∏ —á–∞—Å—Ç–æ—Ç—ã
                    const r = baseRadius + (percent * maxRadius * 0.7);
                    
                    // –£–≥–æ–ª –≤–Ω—É—Ç—Ä–∏ —Å–µ–≥–º–µ–Ω—Ç–∞: —Ä–∞—Å—Ç—è–≥–∏–≤–∞–µ–º —Ç–æ—á–∫–∏ –≤–µ–µ—Ä–æ–º
                    const theta = (i / bufferLength) * (Math.PI / 2); // –†–∏—Å—É–µ–º –∫–∞–∫ –±—ã "–ª–µ–ø–µ—Å—Ç–æ–∫"

                    const x = r * Math.sin(theta);
                    const y = r * Math.cos(theta);

                    // –°–æ–µ–¥–∏–Ω—è–µ–º —Ç–æ—á–∫–∏ –ø–ª–∞–≤–Ω—ã–º–∏ –∫–≤–∞–¥—Ä–∞—Ç–∏—á–Ω—ã–º–∏ –∫—Ä–∏–≤—ã–º–∏, –∞ –Ω–µ –ø—Ä—è–º—ã–º–∏ –ª–∏–Ω–∏—è–º–∏
                    const cpX = (prevX + x) / 2;
                    const cpY = (prevY + y) / 2;
                    canvasCtx.quadraticCurveTo(prevX, prevY, cpX, cpY);

                    prevX = x;
                    prevY = y;
                }
                
                // –ó–∞–º—ã–∫–∞–µ–º –∫—Ä–∏–≤—É—é –æ–±—Ä–∞—Ç–Ω–æ –∫ —Ü–µ–Ω—Ç—Ä—É –¥–ª—è —Ñ–æ—Ä–º—ã –ª–µ–ø–µ—Å—Ç–∫–∞
                canvasCtx.quadraticCurveTo(prevX, prevY, 0, baseRadius * 1.5);
                
                canvasCtx.stroke();
                canvasCtx.restore();
            }

            // --- –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ (—è–¥—Ä–æ —Å–µ—Ä–¥—Ü–µ–±–∏–µ–Ω–∏—è) ---
            if (bassEnergy > 0.15) {
                canvasCtx.beginPath();
                canvasCtx.arc(centerX, centerY, baseRadius * 0.8, 0, 2 * Math.PI);
                canvasCtx.fillStyle = `hsla(${hueOffset}, 100%, 70%, ${bassEnergy * 0.3})`;
                canvasCtx.fill();
                
                // –í—Ç–æ—Ä–æ–µ –∫–æ–ª—å—Ü–æ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ —É–¥–∞—Ä–Ω–æ–π –≤–æ–ª–Ω—ã
                canvasCtx.beginPath();
                canvasCtx.arc(centerX, centerY, baseRadius * 1.2 + (bassEnergy * 50), 0, 2 * Math.PI);
                canvasCtx.strokeStyle = `hsla(${hueOffset + 180}, 80%, 60%, ${bassEnergy * 0.5})`;
                canvasCtx.lineWidth = 2;
                canvasCtx.stroke();
            }
        }

        // --- –ê—É–¥–∏–æ —Ñ—É–Ω–∫—Ü–∏–∏ ---
        function startDrone() {
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const droneGain = audioCtx.createGain();
            osc1.type = 'sine'; osc1.frequency.value = 65.41; 
            osc2.type = 'triangle'; osc2.frequency.value = 66.5; 
            droneGain.gain.setValueAtTime(0, audioCtx.currentTime);
            droneGain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 4);
            osc1.connect(droneGain); osc2.connect(droneGain);
            droneGain.connect(masterGain);
            osc1.start(); osc2.start();
            return { osc1, osc2, droneGain };
        }

        function playSand(vol) {
            const now = audioCtx.currentTime;
            const bufSize = audioCtx.sampleRate * 4; 
            const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
            const data = buf.getChannelData(0);
            for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource(); noise.buffer = buf;
            const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass';
            filter.frequency.setValueAtTime(600, now);
            filter.frequency.exponentialRampToValueAtTime(100, now + 4); 
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(vol, now + 1.5); 
            gain.gain.linearRampToValueAtTime(0, now + 4);
            noise.connect(filter); filter.connect(gain);
            gain.connect(delayNode); gain.connect(masterGain);
            noise.start(now);
        }

        function playBell(vol) {
            const now = audioCtx.currentTime;
            [1, 1.42, 2.11].forEach((ratio, i) => {
                const osc = audioCtx.createOscillator(); osc.type = 'sine';
                osc.frequency.value = 90 * ratio; 
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(vol / 3, now + 0.5); 
                gain.gain.exponentialRampToValueAtTime(0.001, now + 10 - i); 
                osc.connect(gain); gain.connect(delayNode); gain.connect(masterGain);
                osc.start(now); osc.stop(now + 10);
            });
        }

        function playHeartbeat(vol) {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const beat = (time, accent) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(40, time + 0.1);
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(vol * accent, time + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
                osc.connect(gain);
                gain.connect(masterGain);
                osc.start(time);
                osc.stop(time + 0.6);
            };
            beat(now, 1.0);
            beat(now + 0.35, 0.7); 
        }

        function playRandomNote() {
            if (!isPlaying) return;
            const osc = audioCtx.createOscillator();
            const noteGain = audioCtx.createGain();
            osc.frequency.value = scale[Math.floor(Math.random() * scale.length)];
            osc.type = 'sine';
            const now = audioCtx.currentTime;
            noteGain.gain.setValueAtTime(0, now);
            noteGain.gain.linearRampToValueAtTime(0.08, now + 1.5); 
            noteGain.gain.linearRampToValueAtTime(0, now + 6);    
            osc.connect(noteGain);
            noteGain.connect(masterGain); 
            noteGain.connect(delayNode);  
            osc.start(now);
            osc.stop(now + 6);
            melodyTimeout = setTimeout(playRandomNote, Math.random() * 3000 + 2000);
        }

        // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ---
        function stopAll() {
            synth.cancel();
            clearInterval(keepAliveTimer); 
            
            if (masterGain && audioCtx) masterGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1);
            
            clearTimeout(melodyTimeout);
            Object.values(sfxTimers).forEach(timer => clearInterval(timer));
            sfxFlags = { sand: false, bell: false, heart: false };
            
            if (drawVisualizerRequest) cancelAnimationFrame(drawVisualizerRequest);
            if (canvasCtx) canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);

            document.body.classList.remove('immersed');
            playBtn.textContent = '–ù–∞—á–∞—Ç—å –ø–æ–≥—Ä—É–∂–µ–Ω–∏–µ';
            isPlaying = false;
            
            // --- –î–û–ë–ê–í–õ–ï–ù–ê –≠–¢–ê –°–¢–†–û–ö–ê –î–õ–Ø –ü–ï–†–ï–•–û–î–ê ---
            window.location.href = 'terminal.html';        
        }

        function gracefulStop() {
            clearInterval(keepAliveTimer); 
            playBtn.textContent = '–í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ...';
            
            if (masterGain && audioCtx) {
                masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
                masterGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 8);
            }
            setTimeout(stopAll, 8000);
        }

        // –°–∫—Ä—ã–≤–∞–µ–º/–ø–æ–∫–∞–∑—ã–≤–∞–µ–º UI –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –º—ã—à–∏ (–¥–ª—è —á–∏—Å—Ç–æ—Ç—ã —ç–∫—Ä–∞–Ω–∞)
        let mouseTimer;
        window.addEventListener('mousemove', () => {
            if (isPlaying) {
                document.body.classList.remove('immersed');
                clearTimeout(mouseTimer);
                mouseTimer = setTimeout(() => { document.body.classList.add('immersed'); }, 3000);
            }
        });

        playBtn.addEventListener('click', () => {
            if (isPlaying) return stopAll();

            const selectedVoice = voices.find(v => v.name === voiceSelect.selectedOptions[0].getAttribute('data-name'));
            if (!selectedVoice) return;

            sfxFlags = { sand: false, bell: false, heart: false };
            currentHeartVol = 0.3; 

            const utterThis = new SpeechSynthesisUtterance(textContent);
            utterThis.voice = selectedVoice;
            utterThis.rate = 0.75;
            utterThis.pitch = 0.8;

            utterThis.onboundary = (event) => {
                if (event.name === 'word') {
                    const cleanWord = textContent.substring(event.charIndex, event.charIndex + event.charLength).toLowerCase().replace(/[^–∞-—è—ë]/g, '');
                    
                    if ((cleanWord === '–ø–µ—Å–æ–∫' || cleanWord === '–ø–µ—Å–æ—á–Ω—ã—Ö') && !sfxFlags.sand) {
                        sfxFlags.sand = true;
                        playSand(0.12);
                        sfxTimers.sand = setInterval(() => playSand(0.04), 8000);
                    }
                    if (cleanWord === '–∫–æ–ª–æ–∫–æ–ª–∞' && !sfxFlags.bell) {
                        sfxFlags.bell = true;
                        playBell(0.3);
                        sfxTimers.bell = setInterval(() => playBell(0.08), 12000);
                    }
                    if ((cleanWord === '–≤–æ–∑–¥—É—Ö' || cleanWord === '–ø–ª–æ—Ç–Ω—ã–º') && !sfxFlags.heart) {
                        sfxFlags.heart = true;
                        playHeartbeat(currentHeartVol);
                        sfxTimers.heart = setInterval(() => {
                            if (currentHeartVol < maxHeartVol) currentHeartVol += 0.15;
                            playHeartbeat(currentHeartVol);
                        }, 1500);
                    }
                }
            };

            utterThis.onend = gracefulStop;

            initAudio();
            drawVisualizer();

            isPlaying = true;
            document.body.classList.add('immersed'); // –ü—Ä—è—á–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —á–µ—Ä–µ–∑ CSS
            startDrone();
            playRandomNote(); 
            synth.speak(utterThis);

            keepAliveTimer = setInterval(() => {
                if (synth.speaking && !synth.paused) { synth.pause(); synth.resume(); }
            }, 10000);
            
            playBtn.textContent = '–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å (–í—ã—Ö–æ–¥)';
        });
    </script>
</body>
</html>