<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Terminal Reader // EDITOR vs AI</title>
    <script src="dialogue.js"></script>
    <style>
        :root {
            --bg-color: #080808;
            --terminal-color: #ffb000; 
            --text-color: var(--terminal-color); 
            --editor-color: #00d2ff;
            --ai-color: #ff3333;
            --font-stack: 'Courier New', 'Roboto Mono', Consolas, monospace;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-stack);
            margin: 0;
            padding: 10px;
            height: 100dvh; 
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow: hidden; 
        }

        #terminal-container {
            flex-grow: 1;
            min-height: 0; 
            border: 1px solid var(--text-color);
            padding: 15px;
            overflow-y: auto;
            background-color: rgba(0,0,0,0.6);
            box-shadow: inset 0 0 10px rgba(var(--terminal-color), 0.1);
            display: flex;
            flex-direction: column;
            font-size: 14px;
        }

        #terminal-container::-webkit-scrollbar { width: 4px; }
        #terminal-container::-webkit-scrollbar-track { background: var(--bg-color); }
        #terminal-container::-webkit-scrollbar-thumb { background: var(--text-color); }

        .history-line { margin-bottom: 10px; line-height: 1.4; opacity: 0.6; }
        .current-line-container {
            margin-top: 15px; margin-bottom: 15px;
            font-size: 1.1em; font-weight: bold;
            text-shadow: 0 0 2px var(--text-color);
            min-height: 1.4em;
        }

        .role-prefix { font-weight: bold; margin-right: 8px; letter-spacing: 0.5px; }
        .role-editor { color: var(--editor-color); text-shadow: 0 0 4px var(--editor-color); }
        .role-ai { color: var(--ai-color); text-shadow: 0 0 4px var(--ai-color); }

        .cursor {
            display: inline-block; width: 8px; height: 1.1em;
            background-color: var(--text-color);
            animation: blink 1s step-end infinite;
            vertical-align: text-bottom; margin-left: 2px;
        }
        @keyframes blink { 50% { opacity: 0; } }

        .bottom-panel { flex-shrink: 0; display: flex; flex-direction: column; padding-top: 10px; }

        /* Стили панели конфигурации */
        #config-panel {
            display: none;
            border: 1px dashed var(--text-color);
            padding: 10px;
            margin-bottom: 10px;
            font-size: 12px;
            background: rgba(0,0,0,0.8);
        }
        .config-row {
            display: flex;
            flex-direction: column;
            margin-bottom: 8px;
        }
        .config-row label { margin-bottom: 4px; opacity: 0.8; font-weight: bold; }
        select.terminal-select {
            background: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--text-color);
            padding: 6px;
            font-family: var(--font-stack);
            font-size: 12px;
            width: 100%;
            outline: none;
        }
        select.terminal-select.editor { color: var(--editor-color); border-color: var(--editor-color); }
        select.terminal-select.ai { color: var(--ai-color); border-color: var(--ai-color); }

        .controls { display: flex; gap: 8px; justify-content: space-between; flex-wrap: wrap; }

        .btn-terminal {
            flex: 1; min-width: 22%;
            background: transparent; border: 1px solid var(--text-color);
            color: var(--text-color); padding: 12px 2px; 
            font-family: var(--font-stack); font-weight: bold; font-size: 12px;
            cursor: pointer; text-transform: uppercase; touch-action: manipulation; 
        }
        .btn-terminal:active { background: var(--text-color); color: var(--bg-color); }
        .btn-config { border-style: dashed; }

        .status-bar { margin-top: 8px; font-size: 10px; opacity: 0.5; text-align: center; }

        @media (max-width: 400px) {
            .btn-terminal { font-size: 10px; padding: 10px 1px; }
        }
    </style>
</head>
<body>

    <div id="terminal-container">
        <div id="history-output"></div>
        <div class="current-line-container" id="current-line-block" style="display: none;">
            <span id="current-role-prefix" class="role-prefix"></span>
            <span id="current-text-content"></span><span class="cursor"></span>
        </div>
        <div id="boot-message">
            > BOOT SEQUENCE INITIATED...<br>
            > AWAITING COMMAND...
        </div>
    </div>

    <div class="bottom-panel">
        <div id="config-panel">
            <div class="config-row">
                <label style="color: var(--editor-color)">[ED] EDITOR VOICE (MALE):</label>
                <select id="select-editor" class="terminal-select editor"></select>
            </div>
            <div class="config-row">
                <label style="color: var(--ai-color)">[AI] AI CORE VOICE (FEMALE):</label>
                <select id="select-ai" class="terminal-select ai"></select>
            </div>
        </div>

        <div class="controls">
            <button id="btn-start" class="btn-terminal">[ ► EXEC ]</button>
            <button id="btn-pause" class="btn-terminal">[ ❚❚ PAUSE ]</button>
            <button id="btn-reset" class="btn-terminal">[ ■ RESET ]</button>
            <button id="btn-config" class="btn-terminal btn-config">[ ⚙ CONFIG ]</button>
        </div>
        <div class="status-bar" id="status-bar">SYS.STATUS: STANDBY</div>
    </div>

    <script>
        if (typeof dialogueData === 'undefined') {
            document.getElementById('boot-message').innerHTML += "<br><span style='color:red'>> ERROR: dialogue.js MISSING.</span>";
        }

        const synth = window.speechSynthesis;
        let availableVoices = [];
        let currentIndex = 0;
        let isPlaying = false; 
        let isPausedState = false; 
        
        let typingInterval = null;
        let currentFullText = "";
        let timeoutId = null; 

        const cfgRate = 1.0;
        const cfgPitch = 1.0;
        const cfgTypeSpeed = 60; 
        const cfgPing = 0;       

        const ui = {
            history: document.getElementById('history-output'),
            curBlock: document.getElementById('current-line-block'),
            prefix: document.getElementById('current-role-prefix'),
            text: document.getElementById('current-text-content'),
            boot: document.getElementById('boot-message'),
            status: document.getElementById('status-bar'),
            term: document.getElementById('terminal-container'),
            btnStart: document.getElementById('btn-start'),
            configPanel: document.getElementById('config-panel'),
            selEditor: document.getElementById('select-editor'),
            selAi: document.getElementById('select-ai')
        };

        // Загрузка голосов в списки
        function populateVoiceLists() {
            availableVoices = synth.getVoices();
            if (availableVoices.length === 0) return;

            ui.selEditor.innerHTML = '';
            ui.selAi.innerHTML = '';

            // Показываем русские голоса первыми
            const sortedVoices = [...availableVoices].sort((a, b) => {
                const aRu = a.lang.includes('ru');
                const bRu = b.lang.includes('ru');
                if (aRu && !bRu) return -1;
                if (!aRu && bRu) return 1;
                return 0;
            });

            sortedVoices.forEach(voice => {
                const option1 = document.createElement('option');
                const option2 = document.createElement('option');
                const name = `${voice.name} (${voice.lang})`;
                
                option1.textContent = name; option1.value = voice.name;
                option2.textContent = name; option2.value = voice.name;
                
                ui.selEditor.appendChild(option1);
                ui.selAi.appendChild(option2);
            });

            loadSavedVoices(); // Пытаемся загрузить сохраненный выбор

            ui.boot.style.display = 'none';
            ui.curBlock.style.display = 'block';
            ui.text.innerText = 'СИСТЕМА ГОТОВА К ЗАПУСКУ.';
            ui.prefix.innerText = '> ';
            ui.status.innerText = `SYS.STATUS: READY. VOICES LOADED.`;
        }

        initVoices();
        function initVoices() {
            populateVoiceLists();
        }
        if (speechSynthesis.onvoiceschanged !== undefined) speechSynthesis.onvoiceschanged = initVoices;

        // Сохранение и загрузка настроек из памяти браузера
        function loadSavedVoices() {
            const savedEd = localStorage.getItem('term_voice_editor');
            const savedAi = localStorage.getItem('term_voice_ai');
            
            if (savedEd && availableVoices.some(v => v.name === savedEd)) {
                ui.selEditor.value = savedEd;
            } else {
                // Автовыбор по умолчанию, если ничего не сохранено
                const maleVoice = availableVoices.find(v => v.name.toLowerCase().includes('dmitry') || v.name.toLowerCase().includes('pavel')) || availableVoices.find(v => v.lang.includes('ru'));
                if (maleVoice) ui.selEditor.value = maleVoice.name;
            }

            if (savedAi && availableVoices.some(v => v.name === savedAi)) {
                ui.selAi.value = savedAi;
            } else {
                // Автовыбор по умолчанию для ИИ
                const femaleVoice = availableVoices.find(v => v.name.toLowerCase().includes('svetlana') || v.name.toLowerCase().includes('irina')) || availableVoices.find(v => v.lang.includes('ru') && v.name !== ui.selEditor.value) || availableVoices.find(v => v.lang.includes('ru'));
                if (femaleVoice) ui.selAi.value = femaleVoice.name;
            }
        }

        ui.selEditor.addEventListener('change', () => localStorage.setItem('term_voice_editor', ui.selEditor.value));
        ui.selAi.addEventListener('change', () => localStorage.setItem('term_voice_ai', ui.selAi.value));

        // Логика UI конфигурации
        document.getElementById('btn-config').addEventListener('click', () => {
            if (ui.configPanel.style.display === 'none' || ui.configPanel.style.display === '') {
                ui.configPanel.style.display = 'block';
            } else {
                ui.configPanel.style.display = 'none';
            }
        });

        // Функция получения выбранного объекта голоса
        function getVoiceObject(role) {
            const voiceName = role === 'editor' ? ui.selEditor.value : ui.selAi.value;
            return availableVoices.find(v => v.name === voiceName) || availableVoices[0];
        }

        // --- Анимация печати ---
        function startTyping(text) {
            clearInterval(typingInterval);
            ui.text.innerText = "";
            currentFullText = text;
            let i = 0;
            typingInterval = setInterval(() => {
                if (i < text.length) {
                    ui.text.innerText += text.charAt(i);
                    i++;
                    ui.term.scrollTop = ui.term.scrollHeight;
                } else {
                    clearInterval(typingInterval);
                }
            }, cfgTypeSpeed);
        }

        function stopTyping(instantShow = false) {
            clearInterval(typingInterval);
            if (instantShow) ui.text.innerText = currentFullText;
        }

        // --- Воспроизведение ---
        function playDialogue(index) {
            synth.cancel();
            clearTimeout(timeoutId);
            stopTyping();

            if (index >= dialogueData.length) {
                resetState('СЕАНС ЗАВЕРШЕН.');
                return;
            }

            isPlaying = true;
            isPausedState = false;
            ui.btnStart.innerText = "[ ► EXEC ]";
            ui.status.innerText = `SYS.STATUS: RUNNING (${index + 1}/${dialogueData.length})`;

            const data = dialogueData[index];
            const isEd = data.role === 'editor';

            if (index > 0) addToHistory(dialogueData[index - 1]);
            else ui.history.innerHTML = '';

            ui.prefix.className = 'role-prefix ' + (isEd ? 'role-editor' : 'role-ai');
            ui.prefix.innerText = isEd ? 'ED_>' : 'AI_>';
            
            startTyping(data.text);
            
            currentUtterance = new SpeechSynthesisUtterance(data.text);
            
            // Назначаем голос из выбранных в настройках!
            currentUtterance.voice = getVoiceObject(data.role);
            currentUtterance.rate = cfgRate;
            currentUtterance.pitch = cfgPitch;

            currentUtterance.onend = () => {
                if (isPlaying && !isPausedState) {
                    currentIndex++;
                    timeoutId = setTimeout(() => playDialogue(currentIndex), cfgPing);
                }
            };
            
            currentUtterance.onerror = (e) => {
                 if(isPlaying && !isPausedState) {
                      synth.cancel();
                      timeoutId = setTimeout(() => playDialogue(currentIndex), 1000);
                 }
            };

            synth.speak(currentUtterance);
        }

        function addToHistory(data) {
            const isEd = data.role === 'editor';
            const div = document.createElement('div');
            div.className = 'history-line';
            div.innerHTML = `<span class="role-prefix ${isEd ? 'role-editor' : 'role-ai'}">${isEd ? '[ED]>' : '[AI]>'}</span> ${data.text}`;
            ui.history.appendChild(div);
            ui.term.scrollTop = ui.term.scrollHeight;
        }

        function resetState(msg) {
            synth.cancel();
            clearTimeout(timeoutId);
            stopTyping();
            currentIndex = 0;
            isPlaying = isPausedState = false;
            ui.history.innerHTML = '';
            ui.prefix.className = 'role-prefix';
            ui.prefix.innerText = '> ';
            ui.text.innerText = msg;
            ui.status.innerText = "SYS.STATUS: STANDBY";
            ui.btnStart.innerText = "[ ► EXEC ]";
        }

        ui.btnStart.addEventListener('click', () => {
            if (isPausedState) {
                ui.status.innerText = "SYS.STATUS: RESUMING...";
                playDialogue(currentIndex);
            } else if (!isPlaying) {
                ui.configPanel.style.display = 'none'; // Прячем панель при старте
                playDialogue(currentIndex);
            }
        });

        document.getElementById('btn-pause').addEventListener('click', () => {
            if (isPlaying && !isPausedState) {
                synth.cancel();
                clearTimeout(timeoutId);
                stopTyping(true);
                isPausedState = true;
                ui.status.innerText = "SYS.STATUS: *** PAUSED ***";
                ui.btnStart.innerText = "[ ► RESUME ]";
            }
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            resetState('СБРОС. ОЖИДАНИЕ КОМАНДЫ.');
            ui.configPanel.style.display = 'none';
        });

    </script>
</body>
</html>
