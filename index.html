<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–°–æ–Ω –≥—É—Å–µ–Ω–∏—Ü—ã</title>
    <style>
        body {
            background-color: #020205; 
            color: #d3d3d3;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end; 
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #visualizer-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
        }
        #ui-container {
            width: 80%; max-width: 400px; text-align: center;
            z-index: 10; margin-bottom: 40px; background: rgba(10, 10, 15, 0.6); 
            padding: 25px; border-radius: 20px; backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.05); box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transition: opacity 2s ease;
        }
        body.immersed #ui-container { opacity: 0.1; }
        body.immersed #ui-container:hover { opacity: 1; }
        #text-source { display: none; }
        .controls { display: flex; flex-direction: column; gap: 15px; align-items: center; }
        select, button {
            padding: 14px; border-radius: 10px; font-size: 1rem; width: 100%; outline: none;
            border: 1px solid rgba(255,255,255,0.1); transition: all 0.3s;
        }
        select { background: rgba(30, 30, 35, 0.9); color: #fff; }
        button {
            background: linear-gradient(135deg, #1a1a24 0%, #2a2a3a 100%);
            color: #fff; cursor: pointer; letter-spacing: 2px;
            text-transform: uppercase; font-weight: bold;
        }
        button:hover {
            background: linear-gradient(135deg, #2a2a3a 0%, #3a3a5a 100%);
            box-shadow: 0 0 20px rgba(100, 150, 255, 0.3); border-color: rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>

    <canvas id="visualizer-canvas"></canvas>

    <div id="ui-container">
        <div class="controls">
            <select id="voiceSelect"><option value="">–ó–∞–≥—Ä—É–∑–∫–∞ –≥–æ–ª–æ—Å–æ–≤...</option></select>
            <button id="playBtn">–ù–∞—á–∞—Ç—å –ø–æ–≥—Ä—É–∂–µ–Ω–∏–µ</button>
        </div>
    </div>

    <div id="text-source">
        –¢–µ–ø–µ—Ä—å —Ç—ã ‚Äî —ç—Ç–æ —Ç–æ–ª—å–∫–æ —Ä–∏—Ç–º. –¢–≤–æ–µ —Ç–µ–ª–æ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ —Ç—è–∂–µ–ª—ã–π, —Ç–µ–ø–ª—ã–π –ø–µ—Å–æ–∫, –∫–æ—Ç–æ—Ä—ã–π –º–µ–¥–ª–µ–Ω–Ω–æ –ø–µ—Ä–µ—Å—ã–ø–∞–µ—Ç—Å—è –≤ –ø–µ—Å–æ—á–Ω—ã—Ö —á–∞—Å–∞—Ö –≤–µ—á–Ω–æ—Å—Ç–∏. –ö–∞–∂–¥–æ–µ —Å–ª–æ–≤–æ ‚Äî —ç—Ç–æ –≥–ª—É–±–æ–∫–∏–π, –±–∞—Ä—Ö–∞—Ç–Ω—ã–π —É–¥–∞—Ä –∫–æ–ª–æ–∫–æ–ª–∞ –≥–¥–µ-—Ç–æ –ø–æ–¥ –≤–æ–¥–æ–π. –¢—ã —á—É–≤—Å—Ç–≤—É–µ—à—å, –∫–∞–∫ –∑–∞—Ç—ã–ª–æ–∫ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –Ω–µ–≤–µ—Å–æ–º—ã–º, –∞ —á–µ–ª—é—Å—Ç—å —Ä–∞—Å—Å–ª–∞–±–ª—è–µ—Ç—Å—è —Å–∞–º–∞ —Å–æ–±–æ–π. –í–æ–∑–¥—É—Ö –≤–æ–∫—Ä—É–≥ —Ç–µ–±—è —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ø–ª–æ—Ç–Ω—ã–º –∏ –ª–∞—Å–∫–æ–≤—ã–º. –°—Ç–µ–Ω—ã –ø—É–ª—å—Å–∏—Ä—É—é—Ç –≤ —Ç–∞–∫—Ç —Ç–≤–æ–µ–º—É –ø—É–ª—å—Å—É. –û–¥–∏–Ω. –î–≤–∞. –ì–ª—É–±–æ–∫–∏–π, —Ç–µ–ø–ª—ã–π –ø–æ–∫–æ–π.
    </div>

    <script>
        // --- –ì–æ–ª–æ—Å–æ–≤–æ–π –¥–≤–∏–∂–æ–∫ ---
        const synth = window.speechSynthesis;
        const voiceSelect = document.getElementById('voiceSelect');
        const playBtn = document.getElementById('playBtn');
        
        // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –∏ —Å—Ä–∞–∑—É —Ä–∞–∑–±–∏–≤–∞–µ–º –µ–≥–æ –Ω–∞ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –ø–æ —Ç–æ—á–∫–∞–º
        const rawText = document.getElementById('text-source').innerText;
        const sentences = rawText.match(/[^.!?]+[.!?]+/g) || [rawText]; 
        
        let voices = [];
        let currentSentenceIndex = 0; // –ò–Ω–¥–µ–∫—Å —Ç–µ–∫—É—â–µ–≥–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è

        function populateVoiceList() {
            voices = synth.getVoices().filter(v => v.lang.startsWith('ru'));
            voiceSelect.innerHTML = '';
            voices.forEach((voice) => {
                const option = document.createElement('option');
                option.textContent = voice.name.includes('Natural') || voice.name.includes('Online') ? 'üåü ' + voice.name : voice.name;
                option.setAttribute('data-name', voice.name);
                if(option.textContent.includes('üåü')) option.selected = true;
                voiceSelect.appendChild(option);
            });
        }
        populateVoiceList();
        if (speechSynthesis.onvoiceschanged !== undefined) speechSynthesis.onvoiceschanged = populateVoiceList;

        // --- –ê—É–¥–∏–æ & –í–∏–∑—É–∞–ª–∏–∑–∞—Ç–æ—Ä ---
        let audioCtx, masterGain, delayNode, feedbackNode, analyser, dataArray, bufferLength;
        let canvas, canvasCtx, WIDTH, HEIGHT;
        let drawVisualizerRequest;
        let isPlaying = false;
        let melodyTimeout;
        let sfxTimers = { sand: null, bell: null, heart: null };
        let sfxFlags = { sand: false, bell: false, heart: false };

        let currentHeartVol = 0.3; 
        const maxHeartVol = 0.8;
        const scale = [130.81, 155.56, 174.61, 196.00, 233.08, 261.63, 311.13];

        function initAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();

            masterGain = audioCtx.createGain();
            masterGain.gain.setValueAtTime(1, audioCtx.currentTime); 
            
            const compressor = audioCtx.createDynamicsCompressor();
            compressor.threshold.setValueAtTime(-24, audioCtx.currentTime);
            compressor.knee.setValueAtTime(30, audioCtx.currentTime);
            compressor.ratio.setValueAtTime(12, audioCtx.currentTime);
            compressor.attack.setValueAtTime(0.003, audioCtx.currentTime);
            compressor.release.setValueAtTime(0.25, audioCtx.currentTime);

            masterGain.connect(compressor);

            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 512; 
            analyser.smoothingTimeConstant = 0.85; 
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);

            compressor.connect(analyser);
            analyser.connect(audioCtx.destination);
            
            delayNode = audioCtx.createDelay();
            delayNode.delayTime.value = 0.6; 
            feedbackNode = audioCtx.createGain();
            feedbackNode.gain.value = 0.5; 
            
            delayNode.connect(feedbackNode);
            feedbackNode.connect(delayNode);
            delayNode.connect(masterGain);

            initCanvas();
        }

        function initCanvas() {
            canvas = document.getElementById('visualizer-canvas');
            canvasCtx = canvas.getContext('2d');
            function resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                WIDTH = window.innerWidth; HEIGHT = window.innerHeight;
                canvas.width = WIDTH * dpr; canvas.height = HEIGHT * dpr;
                canvasCtx.scale(dpr, dpr);
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        }

        let hueOffset = 0; 
        let timeRotation = 0;

        function drawVisualizer() {
            drawVisualizerRequest = requestAnimationFrame(drawVisualizer);
            analyser.getByteFrequencyData(dataArray);

            const centerX = WIDTH / 2; const centerY = HEIGHT / 2;
            const maxRadius = Math.min(WIDTH, HEIGHT) / 2;

            canvasCtx.globalCompositeOperation = 'source-over';
            canvasCtx.fillStyle = 'rgba(2, 2, 5, 0.15)'; 
            canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);
            canvasCtx.globalCompositeOperation = 'lighter';

            const bassEnergy = (dataArray[2] + dataArray[4] + dataArray[6]) / 3 / 255;
            const baseRadius = 40 + bassEnergy * 80; 

            hueOffset += 0.2; timeRotation += 0.001; 
            const segments = 10; 

            for (let m = 0; m < segments; m++) {
                canvasCtx.save();
                canvasCtx.translate(centerX, centerY);
                const angleOffset = (Math.PI * 2 / segments) * m;
                canvasCtx.rotate(timeRotation + angleOffset);
                canvasCtx.beginPath();
                
                const hue = (hueOffset + m * (360 / segments / 2)) % 360; 
                canvasCtx.strokeStyle = `hsla(${hue}, 80%, 60%, 0.6)`;
                canvasCtx.lineWidth = 1.5 + bassEnergy; 
                canvasCtx.shadowBlur = 10;
                canvasCtx.shadowColor = `hsla(${hue}, 100%, 50%, 0.5)`;

                let prevX = 0; let prevY = baseRadius;
                canvasCtx.moveTo(prevX, prevY);

                const step = 4; 
                for (let i = step; i < bufferLength - 20; i += step) {
                    const value = dataArray[i];
                    const percent = value / 255;
                    const r = baseRadius + (percent * maxRadius * 0.7);
                    const theta = (i / bufferLength) * (Math.PI / 2); 
                    const x = r * Math.sin(theta); const y = r * Math.cos(theta);

                    const cpX = (prevX + x) / 2; const cpY = (prevY + y) / 2;
                    canvasCtx.quadraticCurveTo(prevX, prevY, cpX, cpY);
                    prevX = x; prevY = y;
                }
                
                canvasCtx.quadraticCurveTo(prevX, prevY, 0, baseRadius * 1.5);
                canvasCtx.stroke(); canvasCtx.restore();
            }

            if (bassEnergy > 0.15) {
                canvasCtx.beginPath();
                canvasCtx.arc(centerX, centerY, baseRadius * 0.8, 0, 2 * Math.PI);
                canvasCtx.fillStyle = `hsla(${hueOffset}, 100%, 70%, ${bassEnergy * 0.3})`;
                canvasCtx.fill();
                
                canvasCtx.beginPath();
                canvasCtx.arc(centerX, centerY, baseRadius * 1.2 + (bassEnergy * 50), 0, 2 * Math.PI);
                canvasCtx.strokeStyle = `hsla(${hueOffset + 180}, 80%, 60%, ${bassEnergy * 0.5})`;
                canvasCtx.lineWidth = 2; canvasCtx.stroke();
            }
        }

        // --- –ê—É–¥–∏–æ —Ñ—É–Ω–∫—Ü–∏–∏ ---
        function startDrone() {
            const osc1 = audioCtx.createOscillator(); const osc2 = audioCtx.createOscillator();
            const droneGain = audioCtx.createGain();
            osc1.type = 'sine'; osc1.frequency.value = 65.41; 
            osc2.type = 'triangle'; osc2.frequency.value = 66.5; 
            droneGain.gain.setValueAtTime(0, audioCtx.currentTime);
            droneGain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 4);
            osc1.connect(droneGain); osc2.connect(droneGain);
            droneGain.connect(masterGain); osc1.start(); osc2.start();
            return { osc1, osc2, droneGain };
        }

        function playSand(vol) {
            const now = audioCtx.currentTime; const bufSize = audioCtx.sampleRate * 4; 
            const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
            const data = buf.getChannelData(0); for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource(); noise.buffer = buf;
            const filter = audioCtx.createBiquadFilter(); filter.type = 'lowpass';
            filter.frequency.setValueAtTime(600, now); filter.frequency.exponentialRampToValueAtTime(100, now + 4); 
            const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(vol, now + 1.5); gain.gain.linearRampToValueAtTime(0, now + 4);
            noise.connect(filter); filter.connect(gain); gain.connect(delayNode); gain.connect(masterGain); noise.start(now);
        }

        function playBell(vol) {
            const now = audioCtx.currentTime;
            [1, 1.42, 2.11].forEach((ratio, i) => {
                const osc = audioCtx.createOscillator(); osc.type = 'sine'; osc.frequency.value = 90 * ratio; 
                const gain = audioCtx.createGain(); gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(vol / 3, now + 0.5); gain.gain.exponentialRampToValueAtTime(0.001, now + 10 - i); 
                osc.connect(gain); gain.connect(delayNode); gain.connect(masterGain); osc.start(now); osc.stop(now + 10);
            });
        }

        function playHeartbeat(vol) {
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const beat = (time, accent) => {
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(150, time); osc.frequency.exponentialRampToValueAtTime(40, time + 0.1);
                gain.gain.setValueAtTime(0, time); gain.gain.linearRampToValueAtTime(vol * accent, time + 0.02); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
                osc.connect(gain); gain.connect(masterGain); osc.start(time); osc.stop(time + 0.6);
            };
            beat(now, 1.0); beat(now + 0.35, 0.7); 
        }

        function playRandomNote() {
            if (!isPlaying) return;
            const osc = audioCtx.createOscillator(); const noteGain = audioCtx.createGain();
            osc.frequency.value = scale[Math.floor(Math.random() * scale.length)]; osc.type = 'sine';
            const now = audioCtx.currentTime;
            noteGain.gain.setValueAtTime(0, now); noteGain.gain.linearRampToValueAtTime(0.08, now + 1.5); noteGain.gain.linearRampToValueAtTime(0, now + 6);    
            osc.connect(noteGain); noteGain.connect(masterGain); noteGain.connect(delayNode);  
            osc.start(now); osc.stop(now + 6);
            melodyTimeout = setTimeout(playRandomNote, Math.random() * 3000 + 2000);
        }

        // --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ---
        function stopAll() {
            synth.cancel();
            
            if (masterGain && audioCtx) masterGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1);
            
            clearTimeout(melodyTimeout);
            Object.values(sfxTimers).forEach(timer => clearInterval(timer));
            sfxFlags = { sand: false, bell: false, heart: false };
            
            if (drawVisualizerRequest) cancelAnimationFrame(drawVisualizerRequest);
            if (canvasCtx) canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);

            document.body.classList.remove('immersed');
            playBtn.textContent = '–ù–∞—á–∞—Ç—å –ø–æ–≥—Ä—É–∂–µ–Ω–∏–µ';
            isPlaying = false;
            
            // –ü–ï–†–ï–•–û–î –ö –¢–ï–†–ú–ò–ù–ê–õ–£
            window.location.href = 'terminal.html';        
        }

        function gracefulStop() {
            playBtn.textContent = '–í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ...';
            
            if (masterGain && audioCtx) {
                masterGain.gain.setValueAtTime(masterGain.gain.value, audioCtx.currentTime);
                masterGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 8);
            }
            // –ñ–¥–µ–º 8 —Å–µ–∫—É–Ω–¥ –∑–∞—Ç—É—Ö–∞–Ω–∏—è –º—É–∑—ã–∫–∏, –∑–∞—Ç–µ–º –ø–µ—Ä–µ—Ö–æ–¥–∏–º
            setTimeout(stopAll, 8000);
        }

        // --- –§—É–Ω–∫—Ü–∏—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π ---
        function speakNextSentence() {
            if (!isPlaying) return;
            
            // –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç –∑–∞–∫–æ–Ω—á–∏–ª—Å—è, –∑–∞–ø—É—Å–∫–∞–µ–º –ø–ª–∞–≤–Ω—ã–π –≤—ã—Ö–æ–¥
            if (currentSentenceIndex >= sentences.length) {
                gracefulStop();
                return;
            }

            const currentSentence = sentences[currentSentenceIndex].trim();
            if (!currentSentence) {
                currentSentenceIndex++;
                return speakNextSentence(); // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
            }

            const utterThis = new SpeechSynthesisUtterance(currentSentence);
            const selectedVoice = voices.find(v => v.name === voiceSelect.selectedOptions[0].getAttribute('data-name'));
            
            if (selectedVoice) utterThis.voice = selectedVoice;
            utterThis.rate = 0.75;
            utterThis.pitch = 0.8;

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ª–æ–≤ –∏ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ –≤–Ω—É—Ç—Ä–∏ —Ç–µ–∫—É—â–µ–≥–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
            utterThis.onboundary = (event) => {
                if (event.name === 'word') {
                    const cleanWord = currentSentence.substring(event.charIndex, event.charIndex + event.charLength).toLowerCase().replace(/[^–∞-—è—ë]/g, '');
                    
                    if ((cleanWord === '–ø–µ—Å–æ–∫' || cleanWord === '–ø–µ—Å–æ—á–Ω—ã—Ö') && !sfxFlags.sand) {
                        sfxFlags.sand = true;
                        playSand(0.12);
                        sfxTimers.sand = setInterval(() => playSand(0.04), 8000);
                    }
                    if (cleanWord === '–∫–æ–ª–æ–∫–æ–ª–∞' && !sfxFlags.bell) {
                        sfxFlags.bell = true;
                        playBell(0.3);
                        sfxTimers.bell = setInterval(() => playBell(0.08), 12000);
                    }
                    if ((cleanWord === '–≤–æ–∑–¥—É—Ö' || cleanWord === '–ø–ª–æ—Ç–Ω—ã–º') && !sfxFlags.heart) {
                        sfxFlags.heart = true;
                        playHeartbeat(currentHeartVol);
                        sfxTimers.heart = setInterval(() => {
                            if (currentHeartVol < maxHeartVol) currentHeartVol += 0.15;
                            playHeartbeat(currentHeartVol);
                        }, 1500);
                    }
                }
            };

            // –ö–∞–∫ —Ç–æ–ª—å–∫–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –¥–æ—á–∏—Ç–∞–Ω–æ - –∑–∞–ø—É—Å–∫–∞–µ–º —Å–ª–µ–¥—É—é—â–µ–µ
            utterThis.onend = () => {
                if (isPlaying) {
                    currentSentenceIndex++;
                    speakNextSentence();
                }
            };

            // –ü–æ–¥—Å—Ç—Ä–∞—Ö–æ–≤–∫–∞ –æ—Ç —Å–±–æ–µ–≤ –¥–≤–∏–∂–∫–∞
            utterThis.onerror = (e) => {
                console.error('TTS Error:', e);
                if (isPlaying) {
                    currentSentenceIndex++;
                    speakNextSentence();
                }
            };

            synth.speak(utterThis);
        }

        let mouseTimer;
        window.addEventListener('mousemove', () => {
            if (isPlaying) {
                document.body.classList.remove('immersed');
                clearTimeout(mouseTimer);
                mouseTimer = setTimeout(() => { document.body.classList.add('immersed'); }, 3000);
            }
        });

        playBtn.addEventListener('click', () => {
            if (isPlaying) return stopAll();

            const selectedVoice = voices.find(v => v.name === voiceSelect.selectedOptions[0].getAttribute('data-name'));
            if (!selectedVoice) return;

            sfxFlags = { sand: false, bell: false, heart: false };
            currentHeartVol = 0.3; 
            currentSentenceIndex = 0; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø—Ä–∏ –Ω–æ–≤–æ–º —Å—Ç–∞—Ä—Ç–µ

            initAudio();
            drawVisualizer();

            isPlaying = true;
            document.body.classList.add('immersed'); 
            startDrone();
            playRandomNote(); 
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Ü–µ–ø–Ω—É—é —Ä–µ–∞–∫—Ü–∏—é —á—Ç–µ–Ω–∏—è –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π
            speakNextSentence();
            
            playBtn.textContent = '–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å (–í—ã—Ö–æ–¥)';
        });
    </script>
</body>

</html>
